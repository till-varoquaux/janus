// -*- tuareg -*-
%{
 open Pos
%}


%token <string> Ident
%token <AstBase.constant> Constant

/* Keywords */

%token If Else While And Not Var Mod EOF
%token Function Or  Return Cps T Macro CpsMacro
%token <string> MacroLiteral

/* Symbols */

%token Lpar Rpar
%token Lsquare Rsquare
%token Lbracket Rbracket
%token Semicolon Comma
%token Colon
%token Arrow DoubleArrow Dot

/* Operators  */

%token Aff // :=
%token Eq // =
%token <AstStd.binop> Comp
%token Plus Minus
%token Star Slash

/* Precedence  */
%nonassoc If
%nonassoc Else

%left Comp Eq
%left Plus Minus Or
%left Star Slash Mod And
%nonassoc uminus
%nonassoc unot

/* Entry point  */
%start program
%type <AstStd.program> program

%%

tyd:
| Colon ty {$2}
| {`T}

arg:
| ident tyd {($1,$2)}

args:
| {[]}
| arg args2 {$1::$2}

args2:
| {[]}
| Comma arg args2 {$2::$3}

expr1:/*can be the LHS of a function call*/
| fundecl Lpar args Rpar tyd bloc {
   let args,args_ty= List.split $3 in
   let f=`Fun (args,$6) in
   let ty=(if $1 then
            `CpsArrow (args_ty,$5)
           else
            `Arrow (args_ty,$5)
          )
   in
   `Typed(f,ty)}
| lvalue {AstStd.lval2expr $1}
| expr2 {$1}

expr2:/*can be the LHS of an array access*/
| Lpar expr Rpar {$2}
| Lsquare exprs Rsquare {`Array $2}
| expr2 Dot ident {`ObjAccess($1,$3)}
| expr2 Lsquare expr Rsquare {`ArrayAccess ($1,$3)}
| expr1 Lpar exprs Rpar {`Call ($1,$3)}

expr_aux:
| Not expr %prec unot {`Unop (`Not,$2)}
| Minus expr %prec uminus {`Unop (`Minus,$2)}
| expr Eq expr {`Binop (`Eq,$1, $3)}
| expr Comp expr {`Binop ($2, $1, $3)}
| expr Plus expr {`Binop (`Add, $1, $3)}
| expr Minus expr {`Binop (`Sub, $1, $3)}
| expr Star expr {`Binop (`Mul, $1, $3)}
| expr Slash expr {`Binop (`Div, $1, $3)}
| expr Mod expr {`Binop (`Mod, $1, $3)}
| expr And expr {`Binop (`And, $1, $3)}
| expr Or expr {`Binop (`Or, $1, $3)}
| Constant {`Cst $1}
| expr1 {$1}

fundecl:
| Function {false}
| Cps {true}

expr:
| expr_aux {`Pos ((symbol_start_pos(),symbol_end_pos()),$1)}

exprs:
| {[]}
| expr exprs2 {$1::$2}

exprs2:
| {[]}
| Comma expr exprs2 {$2::$3}

lvalue:
| ident {`Ident $1}
| lvalue Lsquare expr Rsquare {`ArrayAccess($1,$3)}
| lvalue Dot ident {`ObjAccess($1,$3)}

cond:
| Lpar expr Rpar {$2}

macroelem:
| ident {`Ident $1}
| MacroLiteral {`Literal $1}

macrobloc:
| {[]}
| macroelem macrobloc {$1::$2}

instr:
| instr_aux {`Pos ((symbol_start_pos(),symbol_end_pos()),$1)}

instr_aux:
| Macro ident Lpar args Rpar  macrobloc {
   let args,args_ty= List.split $4 in
   `Macro ($2,args,$6,args_ty)
  }
| CpsMacro ident Lpar args Rpar  macrobloc {
   let args,args_ty= List.split $4 in
   `CpsMacro ($2,args,$6,args_ty)
  }
| Var ident Eq expr {`Var ($2,$4)}
| lvalue Aff expr {`Assign ($1,$3)}
| If cond bloc_or_instr {`If ($2,$3,`Bloc [])}
| If cond bloc_or_instr Else bloc_or_instr {`If ($2,$3,$5)}
| While cond bloc_or_instr {`While ($2,$3)}
| Return expr {`Ret ($2)}
| expr1 Lpar exprs Rpar {`Call ($1,$3)}

ty:
| T {`T}
| Lpar tys Rpar Arrow ty {`Arrow ($2,$5)}
| Lpar tys Rpar DoubleArrow ty {`CpsArrow ($2,$5)}


tys:
| ty tys2 {$1::$2}
| {[]}

tys2:
| Comma ty tys2 {$2::$3}
| {[]}

bloc:
| Lbracket instrs Rbracket {`Bloc $2}

bloc_or_instr:
| bloc {$1}
| instr {$1}

instrs:
| {[]}
| instr Semicolon instrs {$1::$3}
| instr {[$1]}

ident:
| Ident {{node = $1 ; loc=symbol_start_pos(),symbol_end_pos()}}

program:
| instrs {$1}
